<!DOCTYPE html>
<html>
<head>
<title>Flappy Book</title>
<style>
body {
  margin: 0;
  overflow: hidden;
  background-color: #70c5ce; /* Sky blue background */
}
.container {
      background-image: url('background.png');
      background-size: cover; /* Adjusts the image to cover the entire container */
      background-repeat: no-repeat; /* Ensures the image doesn't repeat */
      background-position: center; /* Centers the image */
      position: relative;
      width: 100%;
      height: 100vh; /* Full viewport height */
      overflow: hidden; /* Hide overflow */
    }
.book {
  position: absolute;
  width: 50px;
  height: 50px;
  font-size: 50px; /* Adjust as needed */
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 10; /* Bring the book to the front */
}
.pipe {
  position: absolute;
  width: 80px;
  background-image: url('pillar.png'); /* Set the background image */
  background-size: contain; /* Adjusts the image to cover the entire pipe */
  background-repeat: repeat-y; /* Repeat the image vertically */
  background-position: center; /* Centers the image */
  right: -80px; /* Start off-screen */
}
.pipe.top {
  top: 0;
}
.pipe.bottom {
  bottom: 0;
}
</style>
</head>
<body>
<div class="container">
  <div class="book">ðŸ“˜</div>
  <div class="pipe top"></div>
  <div class="pipe bottom"></div>
</div>
<script>
const book = document.querySelector('.book');
const container = document.querySelector('.container');
const pipeTop = document.querySelector('.pipe.top');
const pipeBottom = document.querySelector('.pipe.bottom');
let bookY = container.clientHeight / 2;
let bookVelocity = 0;
let gravity = 0.5;
let jumpForce = -8;
let isOpen = false;
let pipeX = container.clientWidth;
let pipeGap = 300;
let pipeWidth = 80;
let score = 0;

function update() {
  // Update book position
  bookY += bookVelocity;
  bookVelocity += gravity;
  book.style.top = `${bookY}px`;

  // Update pipe position
  pipeX -= 6;
  if (pipeX < -pipeWidth) {
    pipeX = container.clientWidth;
    setPipeHeights();
    score++;
  }
  pipeTop.style.right = pipeBottom.style.right = `${container.clientWidth - pipeX}px`;

  // Check for collisions
  if (checkCollision()) {
    gameOver();
    return;
  }

  requestAnimationFrame(update);
}

function checkCollision() {
  const bookRect = book.getBoundingClientRect();
  const topPipeRect = pipeTop.getBoundingClientRect();
  const bottomPipeRect = pipeBottom.getBoundingClientRect();

  return (
    bookRect.right > topPipeRect.left &&
    bookRect.left < topPipeRect.right &&
    (bookRect.top < topPipeRect.bottom || bookRect.bottom > bottomPipeRect.top)
  ) || bookY < 0 || bookY > container.clientHeight - book.clientHeight;
}

function jump() {
  bookVelocity = jumpForce;
  toggleBook();
}

function toggleBook() {
  isOpen = !isOpen;
  book.textContent = isOpen ? 'ðŸ“–' : 'ðŸ“˜';
}

function setPipeHeights() {
  const minHeight = 50;
  const maxHeight = container.clientHeight - pipeGap - minHeight;
  const topHeight = Math.random() * (maxHeight - minHeight) + minHeight;
  pipeTop.style.height = `${topHeight}px`;
  pipeBottom.style.height = `${container.clientHeight - topHeight - pipeGap}px`;
}

function gameOver() {
  alert(`Game Over! Your score: ${score}`);
  resetGame();
}

function resetGame() {
  bookY = container.clientHeight / 2;
  bookVelocity = 0;
  book.style.top = `${bookY}px`;
  book.textContent = 'ðŸ“˜';
  isOpen = false;
  pipeX = container.clientWidth;
  score = 0;
  setPipeHeights();
  requestAnimationFrame(update);
}

// Event listeners for touch and click
container.addEventListener('click', jump);
container.addEventListener('touchstart', (e) => {
  e.preventDefault();
  jump();
});

setPipeHeights();
update();
</script>
</body>
</html>